<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >
  <title>P2Place</title>
  <style>
    #canvas {
      image-rendering: pixelated;
      border: 2px solid #333;
      background-color: #fff;
      background-image:
        linear-gradient(to right, #ccc 1px, transparent 1px),
        linear-gradient(to bottom, #ccc 1px, transparent 1px);
      background-size: 8px 8px;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <h1 class="text-center mb-2">P2Place</h1>
    <p class="text-center lead mb-4">A peer-to-peer implementation of the r/place concept.</p>
    
    <div class="row mb-3 justify-content-center">
      <div class="col-auto d-flex align-items-center">
        <label for="colorPicker" class="form-label mb-0 me-2">Pick a color:</label>
        <input type="color" id="colorPicker" class="form-control form-control-color p-0" value="#000000">
      </div>
    </div>

    <div class="row justify-content-center">
      <div class="col-auto">
        <canvas id="canvas" width="800" height="800" class="d-block"></canvas>
      </div>
    </div>
  </div>

  <script>
    // "fullmesh" or "kgossip"
    const MODE = "{{ mode }}";
  </script>

  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>

  <script>
  (function(){
    const peerId = crypto.randomUUID();
    let lamport = 0;
    const peers = {};          // peerId -> { pc, dc }
    const state = {};          // "x,y" -> { clk, id, color }
    const SIZE = 100, SCALE = 8;

    const cvs = document.getElementById('canvas');
    const ctx = cvs.getContext('2d');
    ctx.scale(SCALE, SCALE);
    ctx.fillStyle = '#FFFFFF';

    /**
     * Paints a single pixel on the canvas.
     * @param {number} x - The x-coordinate (in grid units).
     * @param {number} y - The y-coordinate (in grid units).
     * @param {string} color - The fill color (hex string).
     */
    function paintPixel(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, 1, 1);
    }

    /**
     * Applies a CRDT update message to local state and renders it.
     * Ensures causal ordering via Lamport clocks and peer IDs.
     * @param {Object} msg - The update message.
     * @param {number} msg.x - X grid coordinate.
     * @param {number} msg.y - Y grid coordinate.
     * @param {number} msg.clk - Lamport timestamp.
     * @param {string} msg.id - Peer ID of the sender.
     * @param {string} msg.color - Color to paint.
     */
    function applyUpdate(msg) {
      const key = msg.x + ',' + msg.y;
      const old = state[key] || { clk: 0, id: "", color: "#FFFFFF" };
      if (msg.clk < old.clk) return false;
      if (msg.clk === old.clk && msg.id <= old.id) return false;
      state[key] = { clk: msg.clk, id: msg.id, color: msg.color };
      paintPixel(msg.x, msg.y, msg.color);
      return true;
    }

    /**
     * Broadcasts a message object to all connected peers.
     * @param {Object} msg - The message to broadcast; will be JSON.stringifed.
     */
    function broadcast(msg) {
      const s = JSON.stringify(msg);
      for (const pid in peers) {
        const dc = peers[pid].dc;
        if (dc && dc.readyState === 'open') {
          dc.send(s);
        }
      }
    }

    /**
     * Handles an incoming sync request: sends the entire canvas state.
     * @param {RTCDataChannel} dc - The data channel to respond on.
     */
    function handleSyncReq(dc) {
      const cells = [];
      for (const key in state) {
        const [x, y] = key.split(',').map(Number);
        const { clk, id, color } = state[key];
        cells.push({ x, y, clk, id, color });
      }
      dc.send(JSON.stringify({ type: 'sync_res', cells }));
    }

    /**
     * Processes a sync response by applying each cell update.
     * @param {Object} msg - The sync response message.
     * @param {Array} msg.cells - Array of cell update objects.
     */
    function handleSyncRes(msg) {
      msg.cells.forEach(c => applyUpdate(c));
    }

    /**
     * Sets up event handlers on a newly opened DataChannel.
     * Initiates a state sync request immediately on open.
     * @param {string} remoteId - Peer ID on the other end.
     * @param {RTCDataChannel} dc - The data channel to configure.
     */
    function setupDC(remoteId, dc) {
      dc.onopen = () => {
        dc.send(JSON.stringify({ type: 'sync_req' }));
      };
      dc.onmessage = e => {
        const msg = JSON.parse(e.data);
        switch (msg.type) {
          case 'pixel':
            if (MODE == 'kgossip' && applyUpdate(msg)) {
              broadcast(msg);
            }
            break;
          case 'sync_req':
            handleSyncReq(dc);
            break;
          case 'sync_res':
            handleSyncRes(msg);
            break;
        }
      };
    }

    /**
     * Connects to a remote peer via WebRTC.
     * Creates RTCPeerConnection, handles ICE, and opens a DataChannel if initiator.
     * @param {string} remoteId - Peer ID to connect to.
     */
    function connectToPeer(remoteId) {
      if (peers[remoteId]) return;
      const isInitiator = peerId > remoteId;
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });
      let dc;
      peers[remoteId] = { pc, dc: null };

      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit('signal', {
            to: remoteId, from: peerId,
            signal: { candidate: e.candidate }
          });
        }
      };

      pc.ondatachannel = ev => {
        dc = ev.channel;
        peers[remoteId].dc = dc;
        setupDC(remoteId, dc);
      };

      if (isInitiator) {
        dc = pc.createDataChannel('p2p');
        peers[remoteId].dc = dc;
        setupDC(remoteId, dc);

        pc.createOffer()
          .then(o => pc.setLocalDescription(o))
          .then(() => {
            socket.emit('signal', {
              to: remoteId, from: peerId,
              signal: { description: pc.localDescription }
            });
          });
      }
    }

    cvs.addEventListener('click', e => {
      const rect = cvs.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / SCALE);
      const y = Math.floor((e.clientY - rect.top) / SCALE);
      const color = document.getElementById('colorPicker').value;
      lamport++;
      const msg = { type: 'pixel', x, y, color, clk: lamport, id: peerId };
      applyUpdate(msg);
      broadcast(msg);
    });

    const socket = io();
    socket.on('connect', () => socket.emit('join', { peerId }));
    socket.on('peers', data => data.peers.forEach(id => connectToPeer(id)));
    socket.on('peer-joined', data => connectToPeer(data.peerId));
    socket.on('peer-disconnected', data => {
      const p = peers[data.peerId];
      if (p) {
        p.dc.close();
        p.pc.close();
        delete peers[data.peerId];
      }
    });
    socket.on('signal', async data => {
      const { from, signal } = data;
      if (!peers[from]) connectToPeer(from);
      const { pc } = peers[from];
      if (signal.description) {
        await pc.setRemoteDescription(signal.description);
        if (signal.description.type === 'offer') {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', {
            to: from, from: peerId,
            signal: { description: pc.localDescription }
          });
        }
      }
      if (signal.candidate) {
        try { await pc.addIceCandidate(signal.candidate); }
        catch (err) { console.warn('ICE err', err); }
      }
    });
  })();
  </script>
</body>
</html>
