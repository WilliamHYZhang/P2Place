<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >
  <title>P2Place</title>
  <style>
    #canvas {
      image-rendering: pixelated;
      border: 2px solid #333;
      background-color: #fff;
      background-image:
        linear-gradient(to right, #ccc 1px, transparent 1px),
        linear-gradient(to bottom, #ccc 1px, transparent 1px);
      background-size: 8px 8px;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <h1 class="text-center mb-2">P2Place</h1>
    <p class="text-center lead mb-4">A peer-to-peer implementation of the r/place concept.</p>
    
    <div class="row mb-3 justify-content-center">
      <div class="col-auto d-flex align-items-center">
        <label for="colorPicker" class="form-label mb-0 me-2">Pick a color:</label>
        <input type="color" id="colorPicker" class="form-control form-control-color p-0" value="#000000">
      </div>
    </div>

    <div class="row justify-content-center">
      <div class="col-auto">
        <canvas id="canvas" width="800" height="800" class="d-block"></canvas>
      </div>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>

  <script>
  (function(){
    const peerId = crypto.randomUUID();
    let lamport = 0;
    const peers = {};          // peerId -> { pc, dc }
    const state = {};          // "x,y" -> { clk, id, color }
    const SIZE = 100, SCALE = 8;

    const cvs = document.getElementById('canvas');
    const ctx = cvs.getContext('2d');
    ctx.scale(SCALE, SCALE);
    ctx.fillStyle = '#FFFFFF';
    // ctx.fillRect(0, 0, SIZE, SIZE);

    function paintPixel(x,y,color){
      ctx.fillStyle = color;
      ctx.fillRect(x,y,1,1);
    }

    // conflict-free replicated data type (CRDT) update
    function applyUpdate(msg){
      const key = msg.x + ',' + msg.y;
      const old = state[key] || { clk:0, id:"", color:"#FFFFFF" };
      if (msg.clk < old.clk) return;
      if (msg.clk === old.clk && msg.id <= old.id) return;
      state[key] = { clk: msg.clk, id: msg.id, color: msg.color };
      paintPixel(msg.x, msg.y, msg.color);
    }

    // broadcast pixel updates
    function broadcast(msg){
      const s = JSON.stringify(msg);
      for(const pid in peers){
        const dc = peers[pid].dc;
        if (dc && dc.readyState === 'open') {
          dc.send(s);
        }
      }
    }

    // handle pixel click
    cvs.addEventListener('click', e => {
      const rect = cvs.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left)/SCALE);
      const y = Math.floor((e.clientY - rect.top)/SCALE);
      const color = document.getElementById('colorPicker').value;
      lamport++;
      const msg = { type:'pixel', x, y, color, clk:lamport, id:peerId };
      applyUpdate(msg);
      broadcast(msg);
    });

    // sync functions for new peers
    function handleSyncReq(dc){
      const cells = [];
      for(const key in state){
        const [x,y] = key.split(',').map(Number);
        const { clk,id,color } = state[key];
        cells.push({ x,y,clk,id,color });
      }
      dc.send(JSON.stringify({ type:'sync_res', cells }));
    }
    function handleSyncRes(msg){
      msg.cells.forEach(c => applyUpdate(c));
    }

    // setup connection
    function setupDC(remoteId, dc){
      dc.onopen = () => {
        dc.send(JSON.stringify({ type:'sync_req' }));
      };
      dc.onmessage = e => {
        const msg = JSON.parse(e.data);
        switch(msg.type){
          case 'pixel':
            applyUpdate(msg);
            break;
          case 'sync_req':
            handleSyncReq(dc);
            break;
          case 'sync_res':
            handleSyncRes(msg);
            break;
        }
      };
    }

    // signal via socket.io with server
    const socket = io();
    socket.on('connect', () => {
      socket.emit('join', { peerId });
    });

    socket.on('peers', data => {
      data.peers.forEach(id => connectToPeer(id));
    });
    socket.on('peer-joined', data => {
      connectToPeer(data.peerId);
    });
    socket.on('peer-disconnected', data => {
      const p = peers[data.peerId];
      if(p){
        p.dc.close();
        p.pc.close();
        delete peers[data.peerId];
      }
    });
    // initial handshake logic for new peers
    socket.on('signal', async data => {
      const { from, signal } = data;
      if(!peers[from]) connectToPeer(from, false);
      const { pc } = peers[from];

      if(signal.description){
        await pc.setRemoteDescription(signal.description);
        if(signal.description.type === 'offer'){
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', {
            to: from, from: peerId,
            signal: { description: pc.localDescription }
          });
        }
      }
      if(signal.candidate){
        try { await pc.addIceCandidate(signal.candidate); }
        catch(err){ console.warn('ICE err', err); }
      }
    });

    function connectToPeer(remoteId){
      if(peers[remoteId]) return;
      const isInitiator = peerId > remoteId;
      const pc = new RTCPeerConnection({
        iceServers: [{ urls:'stun:stun.l.google.com:19302' }]
      });
      let dc;
      peers[remoteId] = { pc, dc:null };

      pc.onicecandidate = e => {
        if(e.candidate){
          socket.emit('signal', {
            to: remoteId, from: peerId,
            signal: { candidate: e.candidate }
          });
        }
      };

      pc.ondatachannel = ev => {
        dc = ev.channel;
        peers[remoteId].dc = dc;
        setupDC(remoteId, dc);
      };

      if(isInitiator){
        dc = pc.createDataChannel('p2p');
        peers[remoteId].dc = dc;
        setupDC(remoteId, dc);

        pc.createOffer()
          .then(o => pc.setLocalDescription(o))
          .then(() => {
            socket.emit('signal', {
              to: remoteId, from: peerId,
              signal: { description: pc.localDescription }
            });
          });
      }
    }
  })();
  </script>
</body>
</html>
